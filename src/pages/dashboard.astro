---

---

<html lang="ja">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>VRChat Worlds Dashboard</title>
		<style>
			/* CSS Variables */
			:root {
				--primary-color: #667eea;
				--secondary-color: #764ba2;
				--background-color: #f5f7fa;
				--text-color: #333;
				--text-muted: #666;
				--text-light: #888;
				--border-color: #eee;
				--border-color-light: #ddd;
				--white: #ffffff;
				--error-color: #c33;
				--error-bg: #fee;
				--success-color: #28a745;
				--success-bg: #d4edda;
				--shadow-light: 0 2px 10px rgba(0, 0, 0, 0.1);
				--shadow-medium: 0 4px 15px rgba(0, 0, 0, 0.1);
				--shadow-heavy: 0 8px 25px rgba(0, 0, 0, 0.15);
				--gradient-primary: linear-gradient(
					135deg,
					var(--primary-color) 0%,
					var(--secondary-color) 100%
				);
				--gradient-card: linear-gradient(
					135deg,
					#f8f9fa 0%,
					#e9ecef 100%
				);
				--transition-fast: 0.2s ease;
				--transition-normal: 0.3s ease;
				--border-radius: 8px;
				--border-radius-large: 12px;
				--border-radius-tag: 16px;
				--max-width: 1400px;
				--sidebar-width: 280px;
			}

			/* Reset and Base Styles */
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			body {
				font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
					Roboto, sans-serif;
				background: var(--background-color);
				color: var(--text-color);
				line-height: 1.6;
			}

			/* Layout Components */
			.header {
				background: var(--gradient-primary);
				color: var(--white);
				padding: 1rem 0;
				box-shadow: var(--shadow-light);
				position: sticky;
				top: 0;
				z-index: 100;
			}

			.header-content {
				max-width: var(--max-width);
				margin: 0 auto;
				padding: 0 1rem;
				display: flex;
				justify-content: space-between;
				align-items: center;
			}

			.header h1 {
				font-size: 1.5rem;
				font-weight: 600;
			}

			.folder-title-section {
				position: sticky;
				top: 70px;
				z-index: 90;
				box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
			}

			.main-container {
				max-width: var(--max-width);
				margin: 0 auto;
				display: flex;
				gap: 2rem;
				padding: 2rem 1rem;
			}

			.sidebar {
				width: var(--sidebar-width);
				flex-shrink: 0;
				background: var(--white);
				border-radius: var(--border-radius);
				box-shadow: var(--shadow-light);
				padding: 1.5rem;
				height: fit-content;
				position: sticky;
				top: 120px;
			}

			.main-content {
				flex: 1;
				min-width: 0;
			}

			/* UI Components */
			.user-info {
				display: flex;
				align-items: center;
				gap: 1rem;
			}

			.logout-btn {
				background: rgba(255, 255, 255, 0.2);
				color: var(--white);
				border: 1px solid rgba(255, 255, 255, 0.3);
				padding: 0.5rem 1rem;
				border-radius: 6px;
				cursor: pointer;
				transition: background-color var(--transition-normal);
			}

			.logout-btn:hover {
				background: rgba(255, 255, 255, 0.3);
			}

			/* Status Components */
			.loading {
				text-align: center;
				padding: 2rem;
				font-size: 1.1rem;
				color: var(--text-muted);
			}

			.error {
				background: var(--error-bg);
				color: var(--error-color);
				padding: 1rem;
				border-radius: 6px;
				border-left: 4px solid var(--error-color);
				margin-bottom: 1rem;
			}

			/* Stats Grid */
			.stats {
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
				gap: 1rem;
				margin-bottom: 2rem;
			}

			.stat-card {
				background: var(--white);
				padding: 1.5rem;
				border-radius: var(--border-radius);
				box-shadow: var(--shadow-light);
				text-align: center;
			}

			.stat-number {
				font-size: 2rem;
				font-weight: bold;
				color: var(--primary-color);
				margin-bottom: 0.5rem;
			}

			.stat-label {
				color: var(--text-muted);
				font-size: 0.9rem;
			}

			/* World Cards */
			.worlds-grid {
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
				gap: 1.5rem;
			}

			.world-card {
				background: linear-gradient(
					135deg,
					#f8f9fa 0%,
					#ffffff 50%,
					#f0f2f5 100%
				);
				border-radius: var(--border-radius-large);
				overflow: hidden;
				box-shadow: var(--shadow-medium);
				border: 1px solid rgba(0, 0, 0, 0.05);
				transition:
					transform var(--transition-normal),
					box-shadow var(--transition-normal);
			}

			.world-card:hover {
				transform: translateY(-5px);
				box-shadow: var(--shadow-heavy);
			}

			/* Sidebar Components */
			.sidebar h2 {
				font-size: 1.2rem;
				margin-bottom: 1rem;
				color: var(--text-color);
				border-bottom: 2px solid var(--border-color);
				padding-bottom: 0.5rem;
			}

			.folder-list {
				list-style: none;
				margin: 0;
				padding: 0;
			}

			.folder-item {
				padding: 0.75rem 1rem;
				margin-bottom: 1rem;
				border-radius: var(--border-radius);
				cursor: pointer;
				transition: all var(--transition-normal);
				border: 1px solid transparent;
				display: flex;
				justify-content: space-between;
				align-items: center;
			}

			.folder-item:hover {
				background: var(--background-color);
				border-color: var(--border-color-light);
			}

			.folder-item.active {
				background: var(--gradient-primary);
				color: var(--white);
				border-color: var(--primary-color);
			}

			.folder-actions {
				display: flex;
				gap: 0.25rem;
				opacity: 0;
				transition: opacity var(--transition-normal);
			}

			.folder-item:hover .folder-actions {
				opacity: 1;
			}

			.btn {
				padding: 0.5rem 1rem;
				border: none;
				border-radius: var(--border-radius);
				cursor: pointer;
				transition: all var(--transition-normal);
				font-size: 0.9rem;
				font-weight: 500;
			}

			.btn-primary {
				background: var(--primary-color);
				color: var(--white);
			}

			.btn-primary:hover {
				background: var(--secondary-color);
			}

			.btn-secondary {
				background: var(--white);
				color: var(--text-color);
				border: 1px solid var(--border-color);
			}

			.btn-secondary:hover {
				background: var(--background-color);
			}

			.btn-small {
				padding: 0.25rem 0.5rem;
				font-size: 0.8rem;
			}

			.btn-danger {
				background: var(--error-color);
				color: var(--white);
				border: none;
			}

			.btn-danger:hover {
				background: #a02622;
			}

			/* Ensure button styles override defaults */
			.folder-actions .btn {
				padding: 0.25rem 0.5rem;
				font-size: 0.75rem;
				border-radius: 4px;
				margin-left: 0.25rem;
			}

			.world-card-actions .btn {
				padding: 0.25rem 0.5rem;
				font-size: 0.75rem;
				border-radius: 4px;
				margin-left: 0.25rem;
			}

			/* World Management */
			.world-actions {
				display: flex;
				gap: 1rem;
				margin-bottom: 2rem;
				align-items: center;
				flex-wrap: wrap;
			}

			.world-input {
				padding: 0.5rem;
				border: 1px solid var(--border-color);
				border-radius: var(--border-radius);
				flex: 1;
				min-width: 300px;
			}

			.world-card {
				background: linear-gradient(
					135deg,
					#f8f9fa 0%,
					#ffffff 50%,
					#f0f2f5 100%
				);
				border-radius: var(--border-radius-large);
				overflow: hidden;
				box-shadow: var(--shadow-medium);
				border: 1px solid rgba(0, 0, 0, 0.05);
				transition:
					transform var(--transition-normal),
					box-shadow var(--transition-normal);
				position: relative;
			}

			.world-card:hover {
				transform: translateY(-5px);
				box-shadow: var(--shadow-heavy);
			}

			.world-card-actions {
				position: absolute;
				top: 1rem;
				right: 1rem;
				display: flex;
				gap: 0.5rem;
				opacity: 0;
				transition: opacity var(--transition-normal);
			}

			.world-card:hover .world-card-actions {
				opacity: 1;
			}

			/* Modal */
			.modal {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: rgba(0, 0, 0, 0.5);
				display: flex;
				justify-content: center;
				align-items: center;
				z-index: 1000;
			}

			.modal-content {
				background: var(--white);
				padding: 2rem;
				border-radius: var(--border-radius-large);
				box-shadow: var(--shadow-heavy);
				max-width: 500px;
				width: 90%;
				max-height: 80vh;
				overflow-y: auto;
			}

			.modal h3 {
				margin-bottom: 1rem;
				color: var(--text-color);
			}

			.form-group {
				margin-bottom: 1rem;
			}

			.form-group label {
				display: block;
				margin-bottom: 0.5rem;
				color: var(--text-color);
				font-weight: 500;
			}

			.form-group input,
			.form-group textarea {
				width: 100%;
				padding: 0.75rem;
				border: 1px solid var(--border-color);
				border-radius: var(--border-radius);
				font-size: 1rem;
			}

			.form-group textarea {
				resize: vertical;
				min-height: 100px;
			}

			.form-actions {
				display: flex;
				gap: 1rem;
				justify-content: flex-end;
				margin-top: 1.5rem;
			}

			.checkbox-group {
				display: flex;
				align-items: center;
				gap: 0.5rem;
			}

			.checkbox-group input[type="checkbox"] {
				width: auto;
			}

			/* Success Message */
			.success {
				background: var(--success-bg);
				color: var(--success-color);
				padding: 1rem;
				border-radius: 6px;
				border-left: 4px solid var(--success-color);
				margin-bottom: 1rem;
			}

			/* Responsive */
			@media (max-width: 768px) {
				.main-container {
					flex-direction: column;
					gap: 1rem;
				}

				.sidebar {
					width: 100%;
					position: static;
				}

				.world-actions {
					flex-direction: column;
					align-items: stretch;
				}

				.world-input {
					min-width: auto;
				}
			}
		</style>
	</head>
	<body>
		<div class="header">
			<div class="header-content">
				<h1>VRChat Worlds Dashboard</h1>
				<div class="user-info">
					<span id="userDisplay">ユーザー: </span>
					<button class="logout-btn" onclick="logout()"
						>ログアウト</button
					>
				</div>
			</div>
		</div>

		<!-- Current Folder Title -->
		<div class="folder-title-section" style="background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-bottom: 1px solid #dee2e6; padding: 1rem 0;">
			<div class="header-content" style="display: flex; align-items: flex-start; justify-content: space-between;">
				<div style="flex: 1;">
					<h2 id="currentFolderTitle" style="margin: 0; font-size: 1.8rem; font-weight: 600; color: #333; display: flex; align-items: center; gap: 0.75rem;">
						📁 フォルダーを選択してください
					</h2>
					<p id="currentFolderComment" style="margin: 0.5rem 0 0 2.5rem; font-size: 1rem; color: #666; font-style: italic; display: none;"></p>
				</div>
				<div id="currentFolderActions" style="display: none; gap: 0.5rem; margin-top: 0.25rem;"></div>
			</div>
		</div>

		<div class="main-container">
			<div class="sidebar">
				<h2>📁 フォルダー</h2>
				<button
					class="btn btn-primary"
					id="createFolderBtn"
					style="margin-bottom: 1rem; width: 100%;"
					>新しいフォルダー</button
				>
				<ul class="folder-list" id="folderList"></ul>
			</div>

			<div class="main-content">
				<div id="loading" class="loading">データを読み込み中...</div>

				<div id="error" class="error" style="display: none;">
					エラーが発生しました。しばらくしてから再度お試しください。
				</div>

				<div id="success" class="success" style="display: none;">
					操作が完了しました。
				</div>

				<div id="content" style="display: none;">
					<div class="stats" id="stats">
						<div class="stat-card">
							<div class="stat-number" id="totalWorlds">0</div>
							<div class="stat-label">総ワールド数</div>
						</div>
					</div>

					<div class="world-actions">
						<input
							type="text"
							id="worldIdInput"
							class="world-input"
							placeholder="ワールドID (wrld_...) またはVRChatのURLを入力してください"
						/>
						<button class="btn btn-primary" id="addWorldBtn"
							>ワールド追加</button
						>
					</div>

					<div class="worlds-grid" id="worldsGrid"></div>

					<!-- Pagination -->
					<div id="pagination" class="pagination" style="display: none; justify-content: center; align-items: center; gap: 1rem; margin-top: 2rem; padding: 1rem;">
						<button id="prevPageBtn" class="btn btn-secondary" style="padding: 0.5rem 1rem;">← 前のページ</button>
						<div id="pageInfo" style="font-weight: 500; color: #333;"></div>
						<button id="nextPageBtn" class="btn btn-secondary" style="padding: 0.5rem 1rem;">次のページ →</button>
					</div>
				</div>
			</div>
		</div>

		<!-- Folder Modal -->
		<div id="folderModal" class="modal" style="display: none;">
			<div class="modal-content">
				<h3 id="folderModalTitle">新しいフォルダー</h3>
				<div class="form-group">
					<label for="folderName">フォルダー名</label>
					<input type="text" id="folderName" required />
				</div>
				<div class="form-group">
					<label for="folderComment">コメント</label>
					<textarea id="folderComment"></textarea>
				</div>
				<div class="form-group">
					<div class="checkbox-group">
						<input type="checkbox" id="folderPrivate" />
						<label for="folderPrivate">プライベート</label>
					</div>
				</div>
				<div class="form-actions">
					<button class="btn btn-secondary" id="cancelFolderBtn"
						>キャンセル</button
					>
					<button class="btn btn-primary" id="saveFolderBtn"
						>保存</button
					>
				</div>
			</div>
		</div>

		<!-- World Comment Modal -->
		<div id="commentModal" class="modal" style="display: none;">
			<div class="modal-content">
				<h3>コメント編集</h3>
				<div class="form-group">
					<label for="worldComment">コメント</label>
					<textarea
						id="worldComment"
						placeholder="このワールドについてのコメントを入力してください"
					></textarea>
				</div>
				<div class="form-actions">
					<button class="btn btn-secondary" id="cancelCommentBtn"
						>キャンセル</button
					>
					<button class="btn btn-primary" id="saveCommentBtn"
						>保存</button
					>
				</div>
			</div>
		</div>

		<!-- World Details Modal -->
		<div id="worldDetailsModal" class="modal" style="display: none;">
			<div class="modal-content" style="max-width: 800px; width: 90%; max-height: 90vh; overflow-y: auto;">
				<div class="modal-header">
					<h2 class="modal-title">🌍 ワールド詳細</h2>
				</div>
				
				<div id="worldDetailsContent">
					<div class="world-details-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 2rem;">
						<div>
							<img id="worldDetailsImage" style="width: 100%; height: 300px; object-fit: cover; border-radius: 8px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);" src="" alt="ワールド画像" />
						</div>
						<div style="display: flex; flex-direction: column; gap: 1rem;">
							<div>
								<h3 id="worldDetailsTitle" style="font-size: 1.5rem; font-weight: 700; margin-bottom: 0.5rem; color: #333;"></h3>
								<div id="worldDetailsAuthor" style="font-size: 1rem; color: #667eea; margin-bottom: 1rem; padding: 0.5rem; background: #f8f9ff; border-radius: 4px; border-left: 3px solid #667eea;"></div>
							</div>
							
							<div class="world-actions" style="display: flex; gap: 0.75rem; flex-wrap: wrap;">
								<button id="openVRChatBtn" class="btn btn-primary" style="font-size: 0.9rem;">
									🌐 VRChatで開く
								</button>
							</div>
						</div>
					</div>

					<div style="margin-bottom: 2rem;">
						<h4 style="font-size: 1rem; font-weight: 600; color: #444; margin-bottom: 0.5rem;">📝 説明</h4>
						<div id="worldDetailsDescription" style="color: #444; font-size: 0.9rem; line-height: 1.6; padding: 1rem; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 8px; border-left: 4px solid #667eea; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);"></div>
					</div>

					<div class="folders-section" style="background: #f8f9fa; padding: 1.5rem; border-radius: 8px;">
						<h4 style="font-size: 1.2rem; font-weight: 600; margin-bottom: 1rem; color: #333; display: flex; align-items: center; gap: 0.5rem;">📁 フォルダー管理</h4>
						
						<div class="add-folder-form" style="display: flex; gap: 1rem; align-items: center; flex-wrap: wrap; margin-bottom: 1.5rem;">
							<select id="worldDetailsFolderSelect" style="flex: 1; min-width: 200px; padding: 0.5rem; border: 1px solid #ddd; border-radius: 6px; font-size: 0.9rem;">
								<option value="">フォルダーを選択</option>
							</select>
							<input
								type="text"
								id="worldDetailsCommentInput"
								style="flex: 2; min-width: 250px; padding: 0.5rem; border: 1px solid #ddd; border-radius: 6px; font-size: 0.9rem;"
								placeholder="コメント (任意)"
							/>
							<button id="addToFolderDetailsBtn" class="btn btn-primary" style="font-size: 0.9rem;">
								📂 フォルダーに追加
							</button>
						</div>

						<div id="worldDetailsFoldersGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 0.75rem;"></div>
					</div>
				</div>
			</div>
		</div>

		<script>
			// Application Configuration
			const CONFIG = {
				// API_BASE_URL: "https://backend.jmnt34deg.workers.dev",
				API_BASE_URL: "http://localhost:8787",
				PAGE_SIZE: 10,
				DEFAULT_PAGE: 1,
			};

			// Application State
			class DashboardState {
				constructor() {
					this.folders = [];
					this.currentFolder = null;
					this.worldsData = [];
					this.allWorldsData = []; // All worlds data for pagination
					this.totalCount = 0;
					this.currentPage = 1;
					this.totalPages = 1;
					this.userId = null;
					this.editingFolder = null;
					this.editingWorld = null;
				}

				setUserId(userId) {
					this.userId = userId;
				}

				setFolders(folders) {
					this.folders = folders;
				}

				setCurrentFolder(folder) {
					this.currentFolder = folder;
				}

				setWorldsData(data) {
					this.allWorldsData = data;
					this.totalCount = data.length;
					this.totalPages = Math.ceil(data.length / CONFIG.PAGE_SIZE);
					this.updateCurrentPageData();
				}

				updateCurrentPageData() {
					const startIndex = (this.currentPage - 1) * CONFIG.PAGE_SIZE;
					const endIndex = startIndex + CONFIG.PAGE_SIZE;
					this.worldsData = this.allWorldsData.slice(startIndex, endIndex);
				}

				setCurrentPage(page) {
					this.currentPage = Math.max(1, Math.min(page, this.totalPages));
					this.updateCurrentPageData();
				}

				resetPagination() {
					this.currentPage = 1;
					this.updateCurrentPageData();
				}

				setEditingFolder(folder) {
					this.editingFolder = folder;
				}

				setEditingWorld(world) {
					this.editingWorld = world;
				}
			}

			// API Service for v2 endpoints
			class ApiService {
				constructor(baseUrl) {
					this.baseUrl = baseUrl;
				}

				// Folder operations
				async fetchFolders(userId) {
					const url = `${this.baseUrl}/v2/u/${userId}/folders`;
					const response = await fetch(url);
					if (!response.ok) {
						throw new Error(
							`HTTP error! status: ${response.status}`,
						);
					}
					return await response.json();
				}

				async createFolder(userId, folderData) {
					const url = `${this.baseUrl}/v2/u/${userId}/folders`;
					const response = await fetch(url, {
						method: "POST",
						headers: {
							"Content-Type": "application/json",
						},
						body: JSON.stringify(folderData),
					});
					if (!response.ok) {
						throw new Error(
							`HTTP error! status: ${response.status}`,
						);
					}
					return await response.json();
				}

				async updateFolder(userId, folderId, folderData) {
					const url = `${this.baseUrl}/v2/u/${userId}/folders/${folderId}`;
					const response = await fetch(url, {
						method: "PUT",
						headers: {
							"Content-Type": "application/json",
						},
						body: JSON.stringify(folderData),
					});
					if (!response.ok) {
						throw new Error(
							`HTTP error! status: ${response.status}`,
						);
					}
					return await response.json();
				}

				async deleteFolder(userId, folderId) {
					const url = `${this.baseUrl}/v2/u/${userId}/folders/${folderId}`;
					const response = await fetch(url, {
						method: "DELETE",
					});
					if (!response.ok) {
						throw new Error(
							`HTTP error! status: ${response.status}`,
						);
					}
					return await response.json();
				}

				// Folder items operations
				async fetchFolderItems(userId, folderId) {
					const url = `${this.baseUrl}/v2/u/${userId}/folders/${folderId}/items`;
					const response = await fetch(url);
					if (!response.ok) {
						throw new Error(
							`HTTP error! status: ${response.status}`,
						);
					}
					return await response.json();
				}

				async addWorldToFolder(userId, folderId, worldData) {
					const url = `${this.baseUrl}/v2/u/${userId}/folders/${folderId}/items`;
					const response = await fetch(url, {
						method: "POST",
						headers: {
							"Content-Type": "application/json",
						},
						body: JSON.stringify(worldData),
					});
					if (!response.ok) {
						throw new Error(
							`HTTP error! status: ${response.status}`,
						);
					}
					return await response.json();
				}

				async updateWorldComment(userId, folderId, worldId, comment) {
					const url = `${this.baseUrl}/v2/u/${userId}/folders/${folderId}/items/${worldId}`;
					const response = await fetch(url, {
						method: "PUT",
						headers: {
							"Content-Type": "application/json",
						},
						body: JSON.stringify({ comment }),
					});
					if (!response.ok) {
						throw new Error(
							`HTTP error! status: ${response.status}`,
						);
					}
					return await response.json();
				}

				async removeWorldFromFolder(userId, folderId, worldId) {
					const url = `${this.baseUrl}/v2/u/${userId}/folders/${folderId}/items/${worldId}`;
					const response = await fetch(url, {
						method: "DELETE",
					});
					if (!response.ok) {
						throw new Error(
							`HTTP error! status: ${response.status}`,
						);
					}
					return await response.json();
				}

				// World operations
				async addWorldToMaster(worldId) {
					const url = `${this.baseUrl}/v2/worlds`;
					const response = await fetch(url, {
						method: "POST",
						headers: {
							"Content-Type": "application/json",
						},
						body: JSON.stringify({ world_id: worldId }),
					});
					if (!response.ok) {
						throw new Error(
							`HTTP error! status: ${response.status}`,
						);
					}
					return await response.json();
				}

				async updateWorldInfo(worldId) {
					const url = `${this.baseUrl}/v2/worlds/${worldId}`;
					const response = await fetch(url, {
						method: "PUT",
					});
					if (!response.ok) {
						throw new Error(
							`HTTP error! status: ${response.status}`,
						);
					}
					return await response.json();
				}
			}

			// UI Service
			class UIService {
				constructor() {
					this.elements = {
						loading: document.getElementById("loading"),
						error: document.getElementById("error"),
						success: document.getElementById("success"),
						content: document.getElementById("content"),
						userDisplay: document.getElementById("userDisplay"),
						totalWorlds: document.getElementById("totalWorlds"),
						currentFolderTitle: document.getElementById("currentFolderTitle"),
						worldsGrid: document.getElementById("worldsGrid"),
						folderList: document.getElementById("folderList"),
						worldIdInput: document.getElementById("worldIdInput"),
						addWorldBtn: document.getElementById("addWorldBtn"),
						createFolderBtn:
							document.getElementById("createFolderBtn"),
						folderModal: document.getElementById("folderModal"),
						commentModal: document.getElementById("commentModal"),
					};
				}

				showLoading() {
					this.elements.loading.style.display = "block";
					this.elements.content.style.display = "none";
					this.elements.error.style.display = "none";
					this.elements.success.style.display = "none";
				}

				showContent() {
					this.elements.loading.style.display = "none";
					this.elements.content.style.display = "block";
					this.elements.error.style.display = "none";
				}

				showError(message = null) {
					this.elements.loading.style.display = "none";
					this.elements.content.style.display = "none";
					this.elements.error.style.display = "block";
					this.elements.success.style.display = "none";
					if (message) {
						this.elements.error.textContent = message;
					}
				}

				showSuccess(message) {
					this.elements.success.textContent = message;
					this.elements.success.style.display = "block";
					setTimeout(() => {
						this.elements.success.style.display = "none";
					}, 3000);
				}

				updateUserDisplay(userId) {
					this.elements.userDisplay.textContent = `ユーザー: ${userId}`;
				}

				updateStats(totalCount, folderName, currentFolder = null) {
					this.elements.totalWorlds.textContent = totalCount;
					
					// Update folder title
					const folderTitle = document.getElementById('currentFolderTitle');
					const folderComment = document.getElementById('currentFolderComment');
					
					if (folderTitle) {
						folderTitle.textContent = folderName ? `📁 ${folderName}` : '📁 フォルダーを選択してください';
					}
					
					// Update folder comment
					if (folderComment) {
						if (currentFolder && currentFolder.comment && currentFolder.comment.trim()) {
							folderComment.textContent = currentFolder.comment;
							folderComment.style.display = 'block';
						} else {
							folderComment.style.display = 'none';
						}
					}
					
					// Update folder actions
					this.updateCurrentFolderActions(currentFolder);
				}

				updatePagination(currentPage, totalPages, totalCount) {
					const pagination = document.getElementById('pagination');
					const pageInfo = document.getElementById('pageInfo');
					const prevBtn = document.getElementById('prevPageBtn');
					const nextBtn = document.getElementById('nextPageBtn');

					if (totalPages <= 1) {
						pagination.style.display = 'none';
						return;
					}

					pagination.style.display = 'flex';
					pageInfo.textContent = `${currentPage} / ${totalPages} ページ (総 ${totalCount} 件)`;
					
					prevBtn.disabled = currentPage <= 1;
					nextBtn.disabled = currentPage >= totalPages;
					
					prevBtn.style.opacity = currentPage <= 1 ? '0.5' : '1';
					nextBtn.style.opacity = currentPage >= totalPages ? '0.5' : '1';
				}
				
				updateCurrentFolderActions(currentFolder) {
					const actionsDiv = document.getElementById('currentFolderActions');
					actionsDiv.innerHTML = '';
					
					if (currentFolder) {
						actionsDiv.style.display = 'flex';
						
						// Edit button
						const editBtn = document.createElement('button');
						editBtn.className = 'btn btn-small btn-secondary';
						editBtn.textContent = '✏️ 編集';
						editBtn.onclick = () => editFolder(currentFolder.id);
						editBtn.style.cssText = 'padding: 0.5rem 1rem; font-size: 0.8rem; border: 1px solid #667eea; background: white; color: #667eea; border-radius: 6px; cursor: pointer; transition: all 0.2s ease; margin-right: 0.5rem;';
						editBtn.onmouseenter = () => {
							editBtn.style.background = '#667eea';
							editBtn.style.color = 'white';
						};
						editBtn.onmouseleave = () => {
							editBtn.style.background = 'white';
							editBtn.style.color = '#667eea';
						};
						
						// Delete button
						const deleteBtn = document.createElement('button');
						deleteBtn.className = 'btn btn-small btn-danger';
						deleteBtn.textContent = '🗑️ 削除';
						deleteBtn.onclick = () => deleteFolder(currentFolder.id);
						deleteBtn.style.cssText = 'padding: 0.5rem 1rem; font-size: 0.8rem; border: none; background: #c33; color: white; border-radius: 6px; cursor: pointer; transition: all 0.2s ease;';
						deleteBtn.onmouseenter = () => {
							deleteBtn.style.background = '#a02622';
						};
						deleteBtn.onmouseleave = () => {
							deleteBtn.style.background = '#c33';
						};
						
						actionsDiv.appendChild(editBtn);
						actionsDiv.appendChild(deleteBtn);
					} else {
						actionsDiv.style.display = 'none';
					}
				}

				renderFolders(folders, currentFolder) {
					const folderList = this.elements.folderList;

					// Clear existing folders
					folderList.innerHTML = "";

					// Add user folders
					folders.forEach((folder) => {
						const folderItem = document.createElement("li");
						folderItem.className = "folder-item";
						folderItem.dataset.folderId = folder.id;
						if (currentFolder && currentFolder.id === folder.id) {
							folderItem.classList.add("active");
						}

						const folderButton = document.createElement("button");
						folderButton.className = "folder-button";
						folderButton.textContent = `📁 ${folder.folder_name}`;
						folderButton.style.cssText =
							"background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border: 1px solid #dee2e6; text-align: left; width: 100%; padding: 0.75rem 1rem; border-radius: 8px; cursor: pointer; font-size: 0.9rem; font-weight: 500; color: #333; transition: all 0.2s ease; display: flex; align-items: center; justify-content: flex-start; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);";
						folderButton.onclick = (e) => {
							e.stopPropagation();
							window.dashboardController.selectFolder(folder.id);
						};

						// Add hover and active states
						folderButton.onmouseenter = () => {
							folderButton.style.background =
								"linear-gradient(135deg, #667eea 0%, #764ba2 100%)";
							folderButton.style.color = "white";
							folderButton.style.transform = "translateY(-1px)";
							folderButton.style.boxShadow =
								"0 4px 8px rgba(0, 0, 0, 0.1)";
						};
						folderButton.onmouseleave = () => {
							if (!folderItem.classList.contains("active")) {
								folderButton.style.background =
									"linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%)";
								folderButton.style.color = "#333";
								folderButton.style.transform = "translateY(0)";
								folderButton.style.boxShadow =
									"0 2px 4px rgba(0, 0, 0, 0.05)";
							}
						};

						// Set active state styling if this is the current folder
						if (currentFolder && currentFolder.id === folder.id) {
							folderButton.style.background =
								"linear-gradient(135deg, #667eea 0%, #764ba2 100%)";
							folderButton.style.color = "white";
							folderButton.style.boxShadow =
								"0 4px 12px rgba(102, 126, 234, 0.3)";
						}

						folderItem.appendChild(folderButton);

						folderList.appendChild(folderItem);
					});
				}

				createWorldCard(world) {
					const worldCard = document.createElement("div");
					worldCard.className = "world-card";
					worldCard.dataset.worldId = world.world_id;

					// No top action buttons needed anymore

					// Create content div
					const contentDiv = document.createElement("div");
					contentDiv.style.padding = "1.5rem";

					// Create comment section with DOM elements
					const commentSection = document.createElement("div");
					commentSection.style.cssText = "margin-top: 1rem;";
					commentSection.id = `comment-section-${world.world_id}`;

					// Header with label
					const headerDiv = document.createElement("div");
					headerDiv.style.cssText =
						"margin-bottom: 0.5rem;";

					const labelDiv = document.createElement("div");
					labelDiv.style.cssText =
						"font-size: 0.75rem; font-weight: 600; color: #667eea; text-transform: uppercase; letter-spacing: 0.5px;";
					labelDiv.textContent = "💬 コメント";

					headerDiv.appendChild(labelDiv);

					// Comment display
					const displayDiv = document.createElement("div");
					displayDiv.id = `comment-display-${world.world_id}`;
					displayDiv.style.cssText = `color: ${world.comment ? "#667eea" : "#999"}; font-size: 0.9rem; padding: 0.75rem; background: #f0f4ff; border-radius: 6px; border-left: 3px solid #667eea; line-height: 1.5; min-height: 2.5rem; ${!world.comment ? "font-style: italic;" : ""}`;
					displayDiv.textContent =
						world.comment || "コメントがありません";

					// Edit section
					const editDiv = document.createElement("div");
					editDiv.id = `comment-edit-${world.world_id}`;
					editDiv.style.display = "none";

					const textarea = document.createElement("textarea");
					textarea.id = `comment-input-${world.world_id}`;
					textarea.style.cssText =
						"width: 100%; padding: 0.75rem; border: 2px solid #667eea; border-radius: 6px; font-size: 0.9rem; line-height: 1.5; resize: vertical; min-height: 80px; font-family: inherit; box-sizing: border-box;";
					textarea.value = world.comment || "";

					const editButtonsDiv = document.createElement("div");
					editButtonsDiv.style.cssText =
						"display: flex; gap: 0.5rem; margin-top: 0.5rem; justify-content: flex-end;";

					const cancelBtn = document.createElement("button");
					cancelBtn.style.cssText =
						"background: #ddd; color: #333; border: none; padding: 0.5rem 1rem; border-radius: 4px; font-size: 0.8rem; cursor: pointer; transition: background 0.2s ease;";
					cancelBtn.textContent = "キャンセル";
					cancelBtn.onclick = () => cancelCommentEdit(world.world_id);
					cancelBtn.onmouseenter = () =>
						(cancelBtn.style.background = "#ccc");
					cancelBtn.onmouseleave = () =>
						(cancelBtn.style.background = "#ddd");

					const saveBtn = document.createElement("button");
					saveBtn.style.cssText =
						"background: #667eea; color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; font-size: 0.8rem; cursor: pointer; transition: background 0.2s ease;";
					saveBtn.textContent = "保存";
					saveBtn.onclick = () => saveCommentInline(world.world_id);
					saveBtn.onmouseenter = () =>
						(saveBtn.style.background = "#5a6fd8");
					saveBtn.onmouseleave = () =>
						(saveBtn.style.background = "#667eea");

					editButtonsDiv.appendChild(cancelBtn);
					editButtonsDiv.appendChild(saveBtn);
					editDiv.appendChild(textarea);
					editDiv.appendChild(editButtonsDiv);

					// Create buttons div (below comment)
					const buttonsDiv = document.createElement("div");
					buttonsDiv.style.cssText = "display: flex; gap: 0.5rem; margin-top: 0.5rem; justify-content: flex-start;";

					const editBtn = document.createElement("button");
					editBtn.style.cssText =
						"background: #667eea; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; cursor: pointer; transition: background 0.2s ease;";
					editBtn.textContent = "✏️ コメントを編集";
					editBtn.onclick = () => toggleCommentEdit(world.world_id);
					editBtn.onmouseenter = () =>
						(editBtn.style.background = "#5a6fd8");
					editBtn.onmouseleave = () =>
						(editBtn.style.background = "#667eea");

					const deleteBtn = document.createElement("button");
					deleteBtn.style.cssText =
						"background: #c33; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; cursor: pointer; transition: background 0.2s ease;";
					deleteBtn.textContent = "🗑️ フォルダから削除";
					deleteBtn.onclick = () =>
						removeWorldFromCard(world.world_id);
					deleteBtn.onmouseenter = () =>
						(deleteBtn.style.background = "#a02622");
					deleteBtn.onmouseleave = () =>
						(deleteBtn.style.background = "#c33");

					buttonsDiv.appendChild(editBtn);
					buttonsDiv.appendChild(deleteBtn);

					commentSection.appendChild(headerDiv);
					commentSection.appendChild(displayDiv);
					commentSection.appendChild(editDiv);
					commentSection.appendChild(buttonsDiv);

					// Create thumbnail with click handler
					const thumbnailDiv = document.createElement('div');
					thumbnailDiv.style.cssText = 'width: 100%; height: 250px; overflow: hidden; border-radius: 8px; margin-bottom: 1rem; background: #f0f0f0; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease;';
					thumbnailDiv.onmouseenter = () => {
						thumbnailDiv.style.transform = 'scale(1.02)';
						thumbnailDiv.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.15)';
					};
					thumbnailDiv.onmouseleave = () => {
						thumbnailDiv.style.transform = 'scale(1)';
						thumbnailDiv.style.boxShadow = 'none';
					};
					thumbnailDiv.onclick = () => {
						window.dashboardController.openWorldDetails(world.world_id);
					};
					thumbnailDiv.title = 'クリックして詳細を表示';

					const img = document.createElement('img');
					img.src = world.world_thumbnail_image_url;
					img.alt = world.world_name;
					img.style.cssText = 'width: 100%; height: 100%; object-fit: cover; display: block;';
					img.onerror = () => { img.style.display = 'none'; };
					
					thumbnailDiv.appendChild(img);
					contentDiv.appendChild(thumbnailDiv);

					// Create world name section
					const nameSection = document.createElement('div');
					nameSection.style.marginBottom = '0.75rem';
					
					const nameLabel = document.createElement('div');
					nameLabel.style.cssText = 'font-size: 0.75rem; font-weight: 600; color: #333; margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 0.5px;';
					nameLabel.textContent = '🌍 ワールド名';
					
					const nameTitle = document.createElement('h3');
					nameTitle.style.cssText = 'font-size: 1.1rem; font-weight: 600; color: #333; line-height: 1.4; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;';
					nameTitle.textContent = world.world_name;
					
					nameSection.appendChild(nameLabel);
					nameSection.appendChild(nameTitle);
					contentDiv.appendChild(nameSection);

					// Create author section
					const authorSection = document.createElement('div');
					authorSection.style.marginBottom = '0.75rem';
					
					const authorLabel = document.createElement('div');
					authorLabel.style.cssText = 'font-size: 0.75rem; font-weight: 600; color: #667eea; margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 0.5px;';
					authorLabel.textContent = '👤 作者';
					
					const authorDiv = document.createElement('div');
					authorDiv.style.cssText = 'color: #667eea; font-size: 0.9rem; font-weight: 500; padding: 0.5rem; background: #f8f9ff; border-radius: 4px; border-left: 3px solid #667eea;';
					authorDiv.textContent = world.world_author_name;
					
					authorSection.appendChild(authorLabel);
					authorSection.appendChild(authorDiv);
					contentDiv.appendChild(authorSection);

					// Create description section
					const descSection = document.createElement('div');
					descSection.style.marginBottom = '0.75rem';
					
					const descLabel = document.createElement('div');
					descLabel.style.cssText = 'font-size: 0.75rem; font-weight: 600; color: #444; margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 0.5px;';
					descLabel.textContent = '📝 説明';
					
					const descDiv = document.createElement('div');
					descDiv.style.cssText = 'color: #444; font-size: 0.85rem; line-height: 1.6; padding: 0.75rem; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 8px; border-left: 4px solid #667eea; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05); display: -webkit-box; -webkit-line-clamp: 6; -webkit-box-orient: vertical; overflow: hidden;';
					descDiv.textContent = world.world_description;
					
					descSection.appendChild(descLabel);
					descSection.appendChild(descDiv);
					contentDiv.appendChild(descSection);

					// Append the comment section as a DOM element
					contentDiv.appendChild(commentSection);

					worldCard.appendChild(contentDiv);

					return worldCard;
				}

				renderWorlds(worldsData) {
					const grid = this.elements.worldsGrid;
					grid.innerHTML = "";

					if (worldsData.length === 0) {
						grid.innerHTML =
							'<div style="text-align: center; padding: 2rem; color: #666;">このフォルダーにはワールドがありません。</div>';
						return;
					}

					worldsData.forEach((world) => {
						const worldCard = this.createWorldCard(world);
						grid.appendChild(worldCard);
					});
				}

				showModal(modalId) {
					document.getElementById(modalId).style.display = "flex";
				}

				hideModal(modalId) {
					document.getElementById(modalId).style.display = "none";
				}

				clearWorldInput() {
					this.elements.worldIdInput.value = "";
				}
			}

			// Main Dashboard Controller
			class DashboardController {
				constructor() {
					this.state = new DashboardState();
					this.apiService = new ApiService(CONFIG.API_BASE_URL);
					this.uiService = new UIService();

					this.init();
				}

				init() {
					this.checkAuth();
					this.setupEventListeners();
					this.loadData();
				}

				checkAuth() {
					const userId = localStorage.getItem("userId");
					if (!userId) {
						window.location.href = "/";
						return;
					}
					this.state.setUserId(userId);
					this.uiService.updateUserDisplay(userId);
				}

				setupEventListeners() {
					// Folder management
					this.uiService.elements.createFolderBtn.addEventListener(
						"click",
						() => this.showCreateFolderModal(),
					);
					document
						.getElementById("cancelFolderBtn")
						.addEventListener("click", () =>
							this.uiService.hideModal("folderModal"),
						);
					document
						.getElementById("saveFolderBtn")
						.addEventListener("click", () => this.saveFolder());

					// World management
					this.uiService.elements.addWorldBtn.addEventListener(
						"click",
						() => this.addWorld(),
					);
					this.uiService.elements.worldIdInput.addEventListener(
						"keypress",
						(e) => {
							if (e.key === "Enter") this.addWorld();
						},
					);

					// Pagination
					document.getElementById('prevPageBtn').addEventListener('click', () => this.previousPage());
					document.getElementById('nextPageBtn').addEventListener('click', () => this.nextPage());

					// Comment modal
					document
						.getElementById("cancelCommentBtn")
						.addEventListener("click", () =>
							this.uiService.hideModal("commentModal"),
						);
					document
						.getElementById("saveCommentBtn")
						.addEventListener("click", () => this.saveComment());

					// Folder selection
					this.uiService.elements.folderList.addEventListener(
						"click",
						(e) => {
							const folderItem = e.target.closest(".folder-item");
							if (
								folderItem &&
								!e.target.classList.contains("btn")
							) {
								this.selectFolder(folderItem.dataset.folderId);
							}
						},
					);

					// Modal click outside to close
					document.getElementById('folderModal').addEventListener('click', (e) => {
						if (e.target.id === 'folderModal') {
							this.uiService.hideModal('folderModal');
						}
					});

					document.getElementById('commentModal').addEventListener('click', (e) => {
						if (e.target.id === 'commentModal') {
							this.uiService.hideModal('commentModal');
						}
					});

					document.getElementById('worldDetailsModal').addEventListener('click', (e) => {
						if (e.target.id === 'worldDetailsModal') {
							this.hideWorldDetailsModal();
						}
					});
				}

				async loadData() {
					this.uiService.showLoading();

					try {
						// Load folders
						const folders = await this.apiService.fetchFolders(
							this.state.userId,
						);
						this.state.setFolders(folders);
						
						// Auto-select first folder if no folder is selected and folders exist
						if (!this.state.currentFolder && folders.length > 0) {
							this.state.setCurrentFolder(folders[0]);
						}
						
						this.uiService.renderFolders(
							folders,
							this.state.currentFolder,
						);

						// Load worlds for current folder
						await this.loadWorldsForCurrentFolder();

						this.uiService.showContent();
					} catch (error) {
						console.error("Error loading data:", error);
						this.uiService.showError(
							"データの読み込みに失敗しました。",
						);
					}
				}

				async loadWorldsForCurrentFolder() {
					try {
						if (!this.state.currentFolder) {
							// フォルダーが選択されていない場合は空のデータを表示
							this.state.setWorldsData([]);
							this.uiService.updateStats(
								0,
								"フォルダーを選択してください",
								null
							);
							this.uiService.updatePagination(1, 1, 0);
							this.uiService.renderWorlds([]);
							return;
						}

						const worldsData =
							await this.apiService.fetchFolderItems(
								this.state.userId,
								this.state.currentFolder.id,
							);

						this.state.resetPagination(); // Reset to page 1 when loading new folder
						this.state.setWorldsData(worldsData);
						this.uiService.updateStats(
							this.state.totalCount,
							this.state.currentFolder.folder_name,
							this.state.currentFolder
						);
						this.uiService.updatePagination(
							this.state.currentPage,
							this.state.totalPages,
							this.state.totalCount
						);
						this.uiService.renderWorlds(this.state.worldsData);
					} catch (error) {
						console.error("Error loading worlds:", error);
						this.uiService.showError(
							"ワールドの読み込みに失敗しました。",
						);
					}
				}

				previousPage() {
					if (this.state.currentPage > 1) {
						this.state.setCurrentPage(this.state.currentPage - 1);
						this.uiService.updatePagination(
							this.state.currentPage,
							this.state.totalPages,
							this.state.totalCount
						);
						this.uiService.renderWorlds(this.state.worldsData);
					}
				}

				nextPage() {
					if (this.state.currentPage < this.state.totalPages) {
						this.state.setCurrentPage(this.state.currentPage + 1);
						this.uiService.updatePagination(
							this.state.currentPage,
							this.state.totalPages,
							this.state.totalCount
						);
						this.uiService.renderWorlds(this.state.worldsData);
					}
				}

				selectFolder(folderId) {
					const folder = this.state.folders.find(
						(f) => f.id == folderId,
					);
					this.state.setCurrentFolder(folder);

					this.uiService.renderFolders(
						this.state.folders,
						this.state.currentFolder,
					);
					this.loadWorldsForCurrentFolder();
				}

				showCreateFolderModal() {
					this.state.setEditingFolder(null);
					document.getElementById("folderModalTitle").textContent =
						"新しいフォルダー";
					document.getElementById("folderName").value = "";
					document.getElementById("folderComment").value = "";
					document.getElementById("folderPrivate").checked = true;
					this.uiService.showModal("folderModal");
				}

				async saveFolder() {
					const folderName = document
						.getElementById("folderName")
						.value.trim();
					if (!folderName) {
						alert("フォルダー名を入力してください。");
						return;
					}

					const folderData = {
						folder_name: folderName,
						comment: document
							.getElementById("folderComment")
							.value.trim(),
						is_private: document.getElementById("folderPrivate")
							.checked
							? 1
							: 0,
					};

					try {
						if (this.state.editingFolder) {
							await this.apiService.updateFolder(
								this.state.userId,
								this.state.editingFolder.id,
								folderData,
							);
							this.uiService.showSuccess(
								"フォルダーを更新しました。",
							);
						} else {
							await this.apiService.createFolder(
								this.state.userId,
								folderData,
							);
							this.uiService.showSuccess(
								"フォルダーを作成しました。",
							);
						}

						this.uiService.hideModal("folderModal");
						this.loadData();
					} catch (error) {
						console.error("Error saving folder:", error);
						alert("フォルダーの保存に失敗しました。");
					}
				}

				// URLからワールドIDを抽出する関数
				extractWorldIdFromInput(input) {
					const trimmedInput = input.trim();
					
					// 既にワールドIDの場合
					if (trimmedInput.startsWith('wrld_')) {
						return trimmedInput;
					}
					
					// URLからワールドIDを抽出
					const urlPatterns = [
						// https://vrchat.com/home/content/worlds/wrld_xxx/edit
						/vrchat\.com\/home\/content\/worlds\/(wrld_[a-f0-9\-]+)/,
						// https://vrchat.com/home/world/wrld_xxx/info
						/vrchat\.com\/home\/world\/(wrld_[a-f0-9\-]+)/,
						// https://vrchat.com/home/launch?worldId=wrld_xxx
						/vrchat\.com\/home\/launch\?.*worldId=(wrld_[a-f0-9\-]+)/
					];
					
					for (const pattern of urlPatterns) {
						const match = trimmedInput.match(pattern);
						if (match) {
							return match[1];
						}
					}
					
					return null;
				}
				
				async addWorld() {
					const inputValue =
						this.uiService.elements.worldIdInput.value.trim();
					if (!inputValue) {
						alert("ワールドIDまたはVRChatのURLを入力してください。");
						return;
					}

					const worldId = this.extractWorldIdFromInput(inputValue);
					if (!worldId) {
						alert(
							"正しいワールドIDまたはVRChatのURLを入力してください。\n\n対応形式:\n- wrld_xxx (ワールドID)\n- https://vrchat.com/home/content/worlds/wrld_xxx/edit\n- https://vrchat.com/home/world/wrld_xxx/info\n- https://vrchat.com/home/launch?worldId=wrld_xxx",
						);
						return;
					}

					if (!this.state.currentFolder) {
						alert(
							"ワールドを追加するフォルダーを選択してください。",
						);
						return;
					}

					try {
						// First add to master if not exists
						try {
							await this.apiService.addWorldToMaster(worldId);
						} catch (error) {
							// 409 means already exists, which is fine
							if (!error.message.includes("409")) {
								throw error;
							}
						}

						// Then add to folder
						await this.apiService.addWorldToFolder(
							this.state.userId,
							this.state.currentFolder.id,
							{
								world_id: worldId,
							},
						);

						this.uiService.showSuccess("ワールドを追加しました。");
						this.uiService.clearWorldInput();
						this.loadWorldsForCurrentFolder();
					} catch (error) {
						console.error("Error adding world:", error);
						if (error.message.includes("404")) {
							alert(
								"ワールドが見つかりません。ワールドIDを確認してください。",
							);
						} else {
							alert("ワールドの追加に失敗しました。");
						}
					}
				}

				async saveComment() {
					const comment = document
						.getElementById("worldComment")
						.value.trim();

					try {
						await this.apiService.updateWorldComment(
							this.state.userId,
							this.state.currentFolder.id,
							this.state.editingWorld.world_id,
							comment,
						);

						this.uiService.showSuccess("コメントを更新しました。");
						this.uiService.hideModal("commentModal");
						this.loadWorldsForCurrentFolder();
					} catch (error) {
						console.error("Error saving comment:", error);
						alert("コメントの保存に失敗しました。");
					}
				}

				logout() {
					localStorage.removeItem("userId");
					window.location.href = "/";
				}

				async openWorldDetails(worldId) {
					try {
						// Find world data from current loaded worlds
						const worldData = this.state.worldsData.find(w => w.world_id === worldId);
						if (!worldData) {
							alert('ワールドデータが見つかりません。');
							return;
						}

						// Set current world details
						this.currentWorldDetails = {
							...worldData,
							worldInFolders: new Set()
						};

						// Load which folders contain this world
						await this.loadWorldFolderStatus(worldId);

						// Show modal and populate data
						this.showWorldDetailsModal();
						this.populateWorldDetailsModal(worldData);
						this.setupWorldDetailsEventListeners();

					} catch (error) {
						console.error('Error loading world details:', error);
						alert('ワールド詳細の読み込みに失敗しました。');
					}
				}

				async loadWorldFolderStatus(worldId) {
					this.currentWorldDetails.worldInFolders.clear();
					
					for (const folder of this.state.folders) {
						try {
							const items = await this.apiService.fetchFolderItems(this.state.userId, folder.id);
							if (items.some(item => item.world_id === worldId)) {
								this.currentWorldDetails.worldInFolders.add(folder.id);
							}
						} catch (error) {
							console.warn(`Failed to check folder ${folder.id}:`, error);
						}
					}
				}

				showWorldDetailsModal() {
					document.getElementById('worldDetailsModal').style.display = 'flex';
				}

				hideWorldDetailsModal() {
					document.getElementById('worldDetailsModal').style.display = 'none';
				}

				populateWorldDetailsModal(worldData) {
					document.getElementById('worldDetailsTitle').textContent = worldData.world_name || 'Unknown World';
					document.getElementById('worldDetailsAuthor').textContent = `👤 ${worldData.world_author_name || 'Unknown Author'}`;
					document.getElementById('worldDetailsDescription').textContent = worldData.world_description || '説明がありません。';
					
					const worldImage = document.getElementById('worldDetailsImage');
					worldImage.src = worldData.world_thumbnail_image_url || '';
					worldImage.alt = worldData.world_name || 'ワールド画像';

					// Populate folder select
					const folderSelect = document.getElementById('worldDetailsFolderSelect');
					folderSelect.innerHTML = '<option value="">フォルダーを選択</option>';
					
					this.state.folders.forEach(folder => {
						const option = document.createElement('option');
						option.value = folder.id;
						option.textContent = folder.folder_name;
						folderSelect.appendChild(option);
					});

					// Render folders grid
					this.renderWorldDetailsFoldersGrid();
				}

				renderWorldDetailsFoldersGrid() {
					const foldersGrid = document.getElementById('worldDetailsFoldersGrid');
					foldersGrid.innerHTML = '';

					this.state.folders.forEach(folder => {
						const folderCard = document.createElement('div');
						folderCard.style.cssText = 'padding: 0.75rem; border: 1px solid #ddd; border-radius: 6px; background: white; cursor: pointer; transition: all 0.2s ease; position: relative;';
						
						if (this.currentWorldDetails.worldInFolders.has(folder.id)) {
							folderCard.style.borderColor = '#667eea';
							folderCard.style.background = '#f8f9ff';
						}

						folderCard.innerHTML = `
							<div style="font-weight: 600; margin-bottom: 0.25rem;">📁 ${folder.folder_name}</div>
							<div style="font-size: 0.8rem; color: #666;">${folder.comment || 'コメントなし'}</div>
							${this.currentWorldDetails.worldInFolders.has(folder.id) ? '<div style="position: absolute; top: 0.5rem; right: 0.5rem; background: #667eea; color: white; font-size: 0.7rem; padding: 0.2rem 0.4rem; border-radius: 12px;">追加済み</div>' : ''}
						`;

						if (this.currentWorldDetails.worldInFolders.has(folder.id)) {
							folderCard.addEventListener('click', () => this.removeWorldFromFolderDetails(folder.id));
							folderCard.title = 'クリックでフォルダーから削除';
						}

						foldersGrid.appendChild(folderCard);
					});
				}

				setupWorldDetailsEventListeners() {
					// Remove existing listeners
					const openVRChatBtn = document.getElementById('openVRChatBtn');
					const addToFolderBtn = document.getElementById('addToFolderDetailsBtn');

					// Clone to remove all event listeners
					openVRChatBtn.replaceWith(openVRChatBtn.cloneNode(true));
					addToFolderBtn.replaceWith(addToFolderBtn.cloneNode(true));

					// Add new listeners
					document.getElementById('openVRChatBtn').addEventListener('click', () => this.openInVRChat());
					document.getElementById('addToFolderDetailsBtn').addEventListener('click', () => this.addWorldToFolderDetails());
				}

				openInVRChat() {
					const vrchatUrl = `https://vrchat.com/home/world/${this.currentWorldDetails.world_id}/info`;
					window.open(vrchatUrl, '_blank');
				}

				async addWorldToFolderDetails() {
					const folderId = document.getElementById('worldDetailsFolderSelect').value;
					const comment = document.getElementById('worldDetailsCommentInput').value.trim();

					if (!folderId) {
						alert('フォルダーを選択してください。');
						return;
					}

					if (this.currentWorldDetails.worldInFolders.has(parseInt(folderId))) {
						alert('このワールドは既にそのフォルダーに追加されています。');
						return;
					}

					try {
						await this.apiService.addWorldToFolder(this.state.userId, folderId, {
							world_id: this.currentWorldDetails.world_id,
							comment: comment || null
						});

						this.currentWorldDetails.worldInFolders.add(parseInt(folderId));
						this.renderWorldDetailsFoldersGrid();
						
						// Clear form
						document.getElementById('worldDetailsFolderSelect').value = '';
						document.getElementById('worldDetailsCommentInput').value = '';
						
						this.uiService.showSuccess('ワールドをフォルダーに追加しました。');
						
						// Update main dashboard if the folder is currently selected
						if (this.state.currentFolder && this.state.currentFolder.id == folderId) {
							this.loadWorldsForCurrentFolder();
						}
					} catch (error) {
						console.error('Error adding to folder:', error);
						alert('フォルダーへの追加に失敗しました。');
					}
				}

				async removeWorldFromFolderDetails(folderId) {
					if (confirm('このフォルダーからワールドを削除しますか？')) {
						try {
							await this.apiService.removeWorldFromFolder(this.state.userId, folderId, this.currentWorldDetails.world_id);
							this.currentWorldDetails.worldInFolders.delete(folderId);
							this.renderWorldDetailsFoldersGrid();
							this.uiService.showSuccess('フォルダーからワールドを削除しました。');
							
							// Update main dashboard if the folder is currently selected
							if (this.state.currentFolder && this.state.currentFolder.id == folderId) {
								this.loadWorldsForCurrentFolder();
							}
						} catch (error) {
							console.error('Error removing from folder:', error);
							alert('フォルダーからの削除に失敗しました。');
						}
					}
				}
			}

			// Global functions for HTML onclick handlers
			function logout() {
				if (window.dashboardController) {
					window.dashboardController.logout();
				}
			}

			function closeWorldDetailsModal() {
				if (window.dashboardController) {
					window.dashboardController.hideWorldDetailsModal();
				}
			}

			function editFolder(folderId) {
				const folder = window.dashboardController.state.folders.find(
					(f) => f.id == folderId,
				);
				if (folder) {
					window.dashboardController.state.setEditingFolder(folder);
					document.getElementById("folderModalTitle").textContent =
						"フォルダー編集";
					document.getElementById("folderName").value =
						folder.folder_name;
					document.getElementById("folderComment").value =
						folder.comment || "";
					document.getElementById("folderPrivate").checked =
						folder.is_private === 1;
					window.dashboardController.uiService.showModal(
						"folderModal",
					);
				}
			}

			async function deleteFolder(folderId) {
				if (
					confirm(
						"このフォルダーとその中のすべてのワールドを削除しますか？",
					)
				) {
					try {
						await window.dashboardController.apiService.deleteFolder(
							window.dashboardController.state.userId,
							folderId,
						);
						window.dashboardController.uiService.showSuccess(
							"フォルダーを削除しました。",
						);
						window.dashboardController.loadData();
					} catch (error) {
						console.error("Error deleting folder:", error);
						alert("フォルダーの削除に失敗しました。");
					}
				}
			}

			function editWorldComment(worldId, currentComment) {
				if (!window.dashboardController.state.currentFolder) {
					alert("フォルダーを選択してください。");
					return;
				}

				const world = window.dashboardController.state.worldsData.find(
					(w) => w.world_id === worldId,
				);
				if (world) {
					window.dashboardController.state.setEditingWorld(world);
					document.getElementById("worldComment").value =
						currentComment;
					window.dashboardController.uiService.showModal(
						"commentModal",
					);
				}
			}

			async function removeWorld(worldId) {
				if (!window.dashboardController.state.currentFolder) {
					alert("フォルダーを選択してください。");
					return;
				}

				if (confirm("このワールドをフォルダーから削除しますか？")) {
					try {
						await window.dashboardController.apiService.removeWorldFromFolder(
							window.dashboardController.state.userId,
							window.dashboardController.state.currentFolder.id,
							worldId,
						);
						window.dashboardController.uiService.showSuccess(
							"ワールドを削除しました。",
						);
						window.dashboardController.loadWorldsForCurrentFolder();
					} catch (error) {
						console.error("Error removing world:", error);
						alert("ワールドの削除に失敗しました。");
					}
				}
			}

			// Inline comment editing functions
			function toggleCommentEdit(worldId) {
				const displayDiv = document.getElementById(
					`comment-display-${worldId}`,
				);
				const editDiv = document.getElementById(
					`comment-edit-${worldId}`,
				);

				if (editDiv.style.display === "none") {
					displayDiv.style.display = "none";
					editDiv.style.display = "block";
					document.getElementById(`comment-input-${worldId}`).focus();
				} else {
					displayDiv.style.display = "block";
					editDiv.style.display = "none";
				}
			}

			function cancelCommentEdit(worldId) {
				const displayDiv = document.getElementById(
					`comment-display-${worldId}`,
				);
				const editDiv = document.getElementById(
					`comment-edit-${worldId}`,
				);
				const input = document.getElementById(
					`comment-input-${worldId}`,
				);

				// Reset input to original value
				const world = window.dashboardController.state.worldsData.find(
					(w) => w.world_id === worldId,
				);
				input.value = world ? world.comment || "" : "";

				displayDiv.style.display = "block";
				editDiv.style.display = "none";
			}

			async function saveCommentInline(worldId) {
				if (!window.dashboardController.state.currentFolder) {
					alert("フォルダーを選択してください。");
					return;
				}

				const input = document.getElementById(
					`comment-input-${worldId}`,
				);
				const comment = input.value.trim();

				try {
					await window.dashboardController.apiService.updateWorldComment(
						window.dashboardController.state.userId,
						window.dashboardController.state.currentFolder.id,
						worldId,
						comment,
					);

					// Update the display
					const displayDiv = document.getElementById(
						`comment-display-${worldId}`,
					);
					const editDiv = document.getElementById(
						`comment-edit-${worldId}`,
					);

					displayDiv.innerHTML = comment || "コメントがありません";
					displayDiv.style.color = comment ? "#667eea" : "#999";
					displayDiv.style.fontStyle = comment ? "normal" : "italic";

					displayDiv.style.display = "block";
					editDiv.style.display = "none";

					// Update state
					const world =
						window.dashboardController.state.worldsData.find(
							(w) => w.world_id === worldId,
						);
					if (world) {
						world.comment = comment;
					}

					window.dashboardController.uiService.showSuccess(
						"コメントを更新しました。",
					);
				} catch (error) {
					console.error("Error saving comment:", error);
					alert("コメントの保存に失敗しました。");
				}
			}

			function removeWorldFromCard(worldId) {
				removeWorld(worldId);
			}

			// Initialize application when DOM is loaded
			window.addEventListener("load", () => {
				window.dashboardController = new DashboardController();
			});
		</script>
	</body>
</html>
